/*
 * Copyright (C) 2010-2011  George Parisis and Dirk Trossen
 * All rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License version
 * 2 as published by the Free Software Foundation.
 *
 * Alternatively, this software may be distributed under the terms of
 * the BSD license.
 *
 * See LICENSE and COPYING for more details.
 */

#ifndef CLICK_RV_HH
#define CLICK_RV_HH

#include <click/config.h>
#include <click/confparse.hh>
#include <click/error.hh>
#include <click/element.hh>

#include "ba_bitvector.hh"

CLICK_DECLS

class RendezvousInterface;

/**@brief (Blackadder Core) RV implements the rendezvous core function. Pub/sub requests are processed by this Element, which matches publishers with subscribers for all advertised information items.
 * 
 * Depending on the dissemination strategy of an information item or scope, the RV may directly publish notifications to Blackadder nodes or may request some assistance from the Topology Manager.
 * Currently a single rendezvous Element in a domain acts as the domain's rendezvous point.
 * @author George Parisis
 */
class RV : public Element {
public:
    /**
     * @brief Constructor: it does nothing - as Click suggests
     * @return 
     */
    RV();
    /**
     * @brief Destructor: it does nothing - as Click suggests
     * @return 
     */
    ~RV();

    /**
     * @brief the class name - required by Click
     * @return 
     */
    const char *class_name() const {return "RV";}

    /**
     * @brief the port count - required by Click.
     * @return 
     */
    const char *port_count() const {return "-/-";}

    /**
     * @brief a PUSH Element.
     * @return PUSH
     */
    const char *processing() const {return PUSH;}
    /**
     * @brief Element configuration. RV needs only a pointer to the GlovalConf Element so that it can read the Global Configuration.
     */
    int configure(Vector<String>&, ErrorHandler*);

    /**@brief This Element must be configured AFTER the GlobalConf Element
     * @return the correct number so that it is configured afterwards
     */
    int configure_phase() const {return 200;}
    /**@brief Click: Install the element's handlers.
     */
    void add_handlers();
    /**
     * @brief This method is called by Click when the Element is about to be initialized. 
     * Upon initialization, RV subscribes to scope /FFFFFFFFFFFFFFFF to receive pub/sub requests from all Blackadder nodes. It uses the IMPLICIT_RENDEZVOUS strategy. 
     * Therefore the subscription (just like a normal application) is pushed to the Dispatcher and stored there (see Dispatcher).
     * @param errh
     * @return 
     */
    int initialize(ErrorHandler *errh);
    /**@brief Cleanups everything. Upon the cleanup() method invocation, the RV will delete all Scope, InformationItem, and RemoteHost stored in its local indexes.
     */
    void cleanup(CleanupStage stage);
    /**@brief The push() method is called whenever the Dispatcher pushes a packet to the RV.
     * 
     * RV is subscribed to Scope /FFFFFFFFFFFFFFFF when initialized. Therefore, it only expects publications pushed by the Dispatcher. 
     * These publications may be generated by pub/sub requests sent locally by applications or other Click Elements or may arrive from the network (because applications running in other Blackadder nodes issued some pub/pub request).
     * In all cases RV expects them to be compliant with exported API. Therefore, the typeOfAPIEvent should always be PUBLISHED_DATA and the IDOfAPIEvent should always be of the form /FFFFFFFFFFFFFFFF/NodeID.
     * Anything else would be a fatal bug!
     * 
     * RV extracts the node label of the Blackadder node that issued the request (it may be this node) by the information identifier (/FFFFFFFFFFFFFFFF/NodeID) to which this data is published.
     * 
     * Then, it reads the type, the IDLength, ID, prefixIDLength, prefixID and the strategy from the pushed packet.
     * 
     * It finally calls the respective method regarding to the request type.
     * 
     * @param port the port from which the packet was pushed
     * @param p a pointer to the packet
     */
    void push(int port, Packet *p);
    /**@brief Lists all idenfifiers of all scopes and information items.
     *
     * @param t strategy for which information structures are listed
     * @return string representation of all information structures
     */
    String listInfoStructs(int t);

    RendezvousInterface *intra_node_rv;
    RendezvousInterface *intra_domain_rv;
    String nodeID;
    String TMIID;
    /*should be moved in the respective strategy*/
    
    BABitvector TMFID;
};

CLICK_ENDDECLS
#endif

