/*
 * Copyright (C) 2015  George Parisis
 * All rights reserved.
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License version
 * 2 as published by the Free Software Foundation.
 *
 * Alternatively, this software may be distributed under the terms of
 * the BSD license.
 *
 * See LICENSE and COPYING for more details.
 */

#include "tm_graph.h"

using namespace std;

/* maps node labels to vertex descriptors in the boost graph */
map<string, vertex> vertices_map;

/* forwarding information base for the whole network */
per_node_fib_index fib;

/* label of the topology manager */
string topology_manager_label;

void
parse_configuration (boost::property_tree::ptree &pt, const string &filename)
{
  boost::filesystem::path conf_path (filename);
  boost::filesystem::ifstream conf_path_stream;

  if (!boost::filesystem::exists (conf_path)) {
    cerr << "Path " << conf_path << " does not exist. Aborting..." << endl;
    exit (EXIT_FAILURE);
  }

  if (!boost::filesystem::is_regular (conf_path)) {
    cerr << "Path " << conf_path << " is not a regular file. Aborting..." << endl;
    exit (EXIT_FAILURE);
  }

  conf_path_stream.open (conf_path);

  try {
    // Load the .xml file into the property tree. If reading fails
    // (cannot open file, parse error), an exception is thrown.
    read_xml (conf_path_stream, pt);
  } catch (boost::property_tree::xml_parser_error &err) {
    cerr << err.what () << endl;
    exit (EXIT_FAILURE);
  }
}

void
load_network (network_ptr net_ptr, const string &filename)
{
  // Create an empty property tree object
  using boost::property_tree::ptree;
  ptree pt;

  /* parse configuration file */
  parse_configuration (pt, filename);

  try {
    BOOST_FOREACH (ptree::value_type & v, pt.get_child ("network.nodes")) {
      node_ptr n_ptr (new node ());
      load_node (net_ptr, n_ptr, v.second);
      pair<map<string, node_ptr>::iterator, bool> ret = net_ptr->nodes.insert (pair<string, node_ptr> (n_ptr->label, n_ptr));
      if (ret.second == false) {
	cerr << "Node " << n_ptr->label << " is a duplicate. Aborting..." << endl;
	exit (EXIT_FAILURE);
      } else {
	if (n_ptr->is_rv == true) {
	  if (net_ptr->rv_node != NULL) {
	    cerr << "Multiple RV nodes are defined. Aborting..." << endl;
	    exit (EXIT_FAILURE);
	  } else {
	    net_ptr->rv_node = n_ptr;
	  }
	}
	if (n_ptr->is_tm == true) {
	  if (net_ptr->tm_node != NULL) {
	    cerr << "Multiple TM nodes are defined. Aborting..." << endl;
	    exit (EXIT_FAILURE);
	  } else {
	    net_ptr->tm_node = n_ptr;
	  }
	}
      }
    }
  } catch (boost::property_tree::ptree_bad_data& err) {
    cerr << err.what () << endl;
    exit (EXIT_FAILURE);
  } catch (boost::property_tree::ptree_bad_path& err) {
    cerr << "No nodes are defined - aborting..." << endl;
    exit (EXIT_FAILURE);
  }

  try {
    BOOST_FOREACH (ptree::value_type & v, pt.get_child ("network.connections")) {
      connection_ptr c_ptr (new connection ());
      map<string, node_ptr>::iterator src_iter;
      load_connection (c_ptr, v.second);

      /* insert connection in src node connection map */
      /* all connections MUST be unidirectional (that;s the case when the inout file is auto-generated by the deployment tool) */
      src_iter = net_ptr->nodes.find (c_ptr->src_label);
      if (src_iter != net_ptr->nodes.end ()) {
	if (net_ptr->nodes.find (c_ptr->dst_label) != net_ptr->nodes.end ()) {
	  src_iter->second->connections.insert (pair<string, connection_ptr> (c_ptr->dst_label, c_ptr));
	} else {
	  cerr << "Node " << c_ptr->dst_label << " does not exist. Aborting..." << endl;
	  exit (EXIT_FAILURE);
	}
      } else {
	cerr << "Node " << c_ptr->src_label << " does not exist. Aborting..." << endl;
	exit (EXIT_FAILURE);
      }
    }
  } catch (boost::property_tree::ptree_bad_data& err) {
    cerr << err.what () << endl;
    exit (EXIT_FAILURE);
  } catch (boost::property_tree::ptree_bad_path& err) {
    /* this is allowed to support one node deployments for debugging */
    cerr << "No connections are defined " << endl;
  }

  if (net_ptr->tm_node == NULL) {
    cerr << "No TM node is defined. Aborting..." << endl;
    exit (EXIT_FAILURE);
  }
  if (net_ptr->rv_node == NULL) {
    cerr << "No RV node is defined. Aborting..." << endl;
    exit (EXIT_FAILURE);
  }
}

void
load_node (network_ptr net_ptr, node_ptr n_ptr, const boost::property_tree::ptree &pt)
{
  try {
    /* mandatory */
    n_ptr->label = pt.get<string> ("label");
    if (n_ptr->label.length () != NODEID_LEN) {
      cerr << "Label " << n_ptr->label << " is not " << NODEID_LEN << " bytes long. Aborting..." << endl;
      exit (EXIT_FAILURE);
    }

    /* optional - with default values */
    n_ptr->is_rv = pt.get<bool> ("is_rv", false);
    n_ptr->is_tm = pt.get<bool> ("is_tm", false);

    string internal_link_id_str = pt.get<string> ("internal_link_id");
    n_ptr->internal_link_id = bitvector (internal_link_id_str);

  } catch (boost::property_tree::ptree_bad_data& err) {
    cerr << err.what () << endl;
    exit (EXIT_FAILURE);
  } catch (boost::property_tree::ptree_bad_path& err) {
    cerr << "missing mandatory node parameter - " << err.what () << endl;
    exit (EXIT_FAILURE);
  }
}

void
load_connection (connection_ptr c_ptr, const boost::property_tree::ptree &pt)
{
  try {
    /* mandatory */
    c_ptr->src_label = pt.get<string> ("src_label");
    c_ptr->dst_label = pt.get<string> ("dst_label");

    if (c_ptr->src_label.compare (c_ptr->dst_label) == 0) {
      cerr << "src_label and dst_label must not be the same. Aborting..." << endl;
      exit (EXIT_FAILURE);
    }

    string link_id_str = pt.get<string> ("link_id");
    c_ptr->link_id = bitvector (link_id_str);

  } catch (boost::property_tree::ptree_bad_data& err) {
    cerr << err.what () << endl;
    exit (EXIT_FAILURE);
  } catch (boost::property_tree::ptree_bad_path& err) {
    cerr << "missing mandatory connection parameter - " << err.what () << endl;
    exit (EXIT_FAILURE);
  }
}

void
create_graph (network_graph_ptr net_graph_ptr, network_ptr net_ptr)
{
  typedef std::pair<std::string, connection_ptr> connection_map_pair_t;
  typedef std::pair<std::string, node_ptr> node_map_pair_t;

  vertex src_v, dst_v;

  map<string, vertex>::iterator vertices_map_iter;

  /* iterate over all nodes in net_graph and add respective vertices in the graph*/
  BOOST_FOREACH(node_map_pair_t node_pair, net_ptr->nodes) {
    node_ptr src_n_ptr = node_pair.second;
    /* check if this node is already added in the network graph */
    vertices_map_iter = vertices_map.find (src_n_ptr->label);
    if (vertices_map_iter == vertices_map.end ()) {
      /* add the node in the boost graph */
      src_v = add_vertex (src_n_ptr, *net_graph_ptr);
      vertices_map.insert (pair<string, vertex> (src_n_ptr->label, src_v));
    } else {
      src_v = (*vertices_map_iter).second;
    }
    /* iterate over all connections in net_graph and add respective edges in the graph */
    BOOST_FOREACH(connection_map_pair_t connection_pair, src_n_ptr->connections) {
      connection_ptr c_ptr = connection_pair.second;
      node_ptr dst_n_ptr = net_ptr->nodes[c_ptr->dst_label];
      /* check if destination node is a vertex in the boost graph */
      vertices_map_iter = vertices_map.find (dst_n_ptr->label);
      if (vertices_map_iter == vertices_map.end ()) {
	/* add the node in the boost graph */
	dst_v = add_vertex (dst_n_ptr, *net_graph_ptr);
	vertices_map.insert (pair<string, vertex> (dst_n_ptr->label, dst_v));
      } else {
	dst_v = (*vertices_map_iter).second;
      }
      /* add the connection in the boost graph */
      add_edge (src_v, dst_v, c_ptr, *net_graph_ptr);
    }
  }
  topology_manager_label = (*net_graph_ptr)[boost::graph_bundle]->tm_node->label;
}

void
calculate_forwarding_id (network_graph_ptr net_graph_ptr, vertex src_v, vertex dst_v, vector<vertex> &predecessor_vector, forwarding_entry_ptr fw_ptr)
{
  vertex predeccesor;
  node_ptr n;

  /* initialise forwarding entry */
  fw_ptr->source = (*net_graph_ptr)[src_v]->label;
  fw_ptr->destination = (*net_graph_ptr)[dst_v]->label;
  fw_ptr->no_hops = 0;
  fw_ptr->lipsin_ptr.reset (new bitvector (FID_LEN * 8));

  /* source node is the same as destination */
  if (dst_v == src_v) {

    /* XOR lipsin with dst_v == src_v internal_link_id and return */
    (*fw_ptr->lipsin_ptr) |= (*net_graph_ptr)[dst_v]->internal_link_id;

    /* internal forwarding is NOT considered a hop */
    return;
  }

  while (true) {
    /* XOR lipsin with dst_v internal_link_id */
    n = (*net_graph_ptr)[dst_v];
    (*fw_ptr->lipsin_ptr) |= n->internal_link_id;

    /* find the predeccesor node */
    predeccesor = predecessor_vector[dst_v];
    pair<edge, bool> edge_pair = boost::edge (predeccesor, dst_v, *net_graph_ptr);
    if (edge_pair.second == false) {
      /* this should never happen - an edge must always exist */
      cout << "Fatal: No edge between " << (*net_graph_ptr)[predeccesor]->label << " and " << (*net_graph_ptr)[dst_v]->label << ". Aborting..." << endl;
      exit (EXIT_FAILURE);
    }
    /* XOR with edge's link_id */
    (*fw_ptr->lipsin_ptr) |= (*net_graph_ptr)[edge_pair.first]->link_id;
    fw_ptr->no_hops++;

    /* done */
    if (predeccesor == src_v) {
      break;
    }

    /* move on to the next iteration */
    dst_v = predeccesor;
  }
}

void
build_forwarding_base (network_graph_ptr net_graph_ptr)
{
  /* iterate over all vertices in the boost graph */
  BOOST_FOREACH(vertex src_v, vertices(*net_graph_ptr)) {
    /* create a map to store all forwarding_entry structs from this node to all nodes */
    per_dst_fw_entry_ptr dst_fw_entry_ptr (new per_dst_fw_entry ());

    /* a predecessor vector used by BFS */
    vector<vertex> predecessor_vector (boost::num_vertices (*net_graph_ptr));

    /* all weights are 1 so, as boost suggests, I am running a BFS with a predecessor map */
    breadth_first_search (*net_graph_ptr, src_v, boost::visitor (boost::make_bfs_visitor (boost::record_predecessors (&predecessor_vector[0], boost::on_tree_edge ()))));

    /* iterate over all vertices in the boost graph */
    BOOST_FOREACH(vertex dst_v, vertices(*net_graph_ptr)) {
      forwarding_entry_ptr fw_ptr (new forwarding_entry ());
      calculate_forwarding_id (net_graph_ptr, src_v, dst_v, predecessor_vector, fw_ptr);
      dst_fw_entry_ptr->insert (per_dst_fw_pair ((*net_graph_ptr)[dst_v]->label, fw_ptr));
    }

    /* add to fib */
    fib.insert (per_node_fib_pair ((*net_graph_ptr)[src_v]->label, dst_fw_entry_ptr));
  }
}

void
print_forwarding_base (network_graph_ptr net_graph_ptr)
{
  cout << "|-----------------------------------FORWARDING INFORMATION BASE-----------------------------------|" << endl;
  /* iterate over all vertices in the boost graph */
  BOOST_FOREACH(vertex src_v, vertices(*net_graph_ptr)) {
    /* iterate over all vertices in the boost graph */
    BOOST_FOREACH(vertex dst_v, vertices(*net_graph_ptr)) {
      forwarding_entry_ptr fw_ptr = (*(*fib.find ((*net_graph_ptr)[src_v]->label)).second->find ((*net_graph_ptr)[dst_v]->label)).second;
      cout << (*net_graph_ptr)[src_v]->label << " --> " << (*net_graph_ptr)[dst_v]->label << ", " << fw_ptr->lipsin_ptr->to_string () << ", " << fw_ptr->no_hops << endl;
    }
  }
  cout << "|-------------------------------------------------------------------------------------------------|" << endl;
}

void
match_pubs_subs (set<string> &publishers, set<string> &subscribers, map<string, boost::shared_ptr<bitvector> > &result)
{
  /* initialise all lipsin identifier pointers in the result map */
  BOOST_FOREACH(string publisher, publishers) {
    boost::shared_ptr<bitvector> lipsin_ptr;
    result.insert (pair<string, boost::shared_ptr<bitvector> > (publisher, lipsin_ptr));
  }

  BOOST_FOREACH(string subscriber, subscribers) {

    string best_publisher;
    boost::shared_ptr<bitvector> best_lipsin_ptr;
    unsigned int no_hops = UINT_MAX;


    BOOST_FOREACH(string publisher, publishers) {
      forwarding_entry_ptr fw_ptr = (*(*fib.find (publisher)).second->find (subscriber)).second;
      if (fw_ptr->no_hops < no_hops) {
	best_publisher = publisher;
	best_lipsin_ptr = fw_ptr->lipsin_ptr;
	no_hops = fw_ptr->no_hops;
      }
    }
    if (!(*result.find (best_publisher)).second) {
      (*result.find (best_publisher)).second.reset (new bitvector (FID_LEN * 8));
    }
    (*(*result.find (best_publisher)).second) |= (*best_lipsin_ptr);
  }
}

boost::shared_ptr<bitvector>
shortest_path (string &source, string &destination)
{
  forwarding_entry_ptr fw_ptr = (*(*fib.find (source)).second->find (destination)).second;
  return fw_ptr->lipsin_ptr;
}
