/*
 * Copyright (C) 2015  George Parisis
 * All rights reserved.
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License version
 * 2 as published by the Free Software Foundation.
 *
 * Alternatively, this software may be distributed under the terms of
 * the BSD license.
 *
 * See LICENSE and COPYING for more details.
 */

#include "tm_graph.h"

using namespace std;

/* maps node labels to vertex descriptors in the boost graph */
map<std::string, vertex> vertices_map;

/* a global routing table */
routing_table rt_table;

void
parse_configuration (boost::property_tree::ptree &pt, const string &filename)
{
  boost::filesystem::path conf_path (filename);
  boost::filesystem::ifstream conf_path_stream;

  if (!boost::filesystem::exists (conf_path)) {
    cerr << "Path " << conf_path << " does not exist. Aborting..." << endl;
    exit (EXIT_FAILURE);
  }

  if (!boost::filesystem::is_regular (conf_path)) {
    cerr << "Path " << conf_path << " is not a regular file. Aborting..." << endl;
    exit (EXIT_FAILURE);
  }

  conf_path_stream.open (conf_path);

  try {
    // Load the .xml file into the property tree. If reading fails
    // (cannot open file, parse error), an exception is thrown.
    read_xml (conf_path_stream, pt);
  } catch (boost::property_tree::xml_parser_error &err) {
    cerr << err.what () << endl;
    exit (EXIT_FAILURE);
  }
}

void
load_network (network_ptr net_ptr, const string &filename)
{
  // Create an empty property tree object
  using boost::property_tree::ptree;
  ptree pt;

  /* parse configuration file */
  parse_configuration (pt, filename);

  try {
    BOOST_FOREACH (ptree::value_type & v, pt.get_child ("network.nodes")) {
      node_ptr n_ptr (new node ());
      load_node (net_ptr, n_ptr, v.second);
      pair<map<string, node_ptr>::iterator, bool> ret = net_ptr->nodes.insert (pair<string, node_ptr> (n_ptr->label, n_ptr));
      if (ret.second == false) {
	cerr << "Node " << n_ptr->label << " is a duplicate. Aborting..." << endl;
	exit (EXIT_FAILURE);
      } else {
	if (n_ptr->is_rv == true) {
	  if (net_ptr->rv_node != NULL) {
	    cerr << "Multiple RV nodes are defined. Aborting..." << endl;
	    exit (EXIT_FAILURE);
	  } else {
	    net_ptr->rv_node = n_ptr;
	  }
	}
	if (n_ptr->is_tm == true) {
	  if (net_ptr->tm_node != NULL) {
	    cerr << "Multiple TM nodes are defined. Aborting..." << endl;
	    exit (EXIT_FAILURE);
	  } else {
	    net_ptr->tm_node = n_ptr;
	  }
	}
      }
    }
  } catch (boost::property_tree::ptree_bad_data& err) {
    cerr << err.what () << endl;
    exit (EXIT_FAILURE);
  } catch (boost::property_tree::ptree_bad_path& err) {
    cerr << "No nodes are defined - aborting..." << endl;
    exit (EXIT_FAILURE);
  }

  try {
    BOOST_FOREACH (ptree::value_type & v, pt.get_child ("network.connections")) {
      connection_ptr c_ptr (new connection ());
      map<string, node_ptr>::iterator src_iter;
      load_connection (c_ptr, v.second);

      /* insert connection in src node connection map */
      /* all connections MUST be unidirectional (that;s the case when the inout file is auto-generated by the deployment tool) */
      src_iter = net_ptr->nodes.find (c_ptr->src_label);
      if (src_iter != net_ptr->nodes.end ()) {
	if (net_ptr->nodes.find (c_ptr->dst_label) != net_ptr->nodes.end ()) {
	  src_iter->second->connections.insert (pair<string, connection_ptr> (c_ptr->dst_label, c_ptr));
	} else {
	  cerr << "Node " << c_ptr->dst_label << " does not exist. Aborting..." << endl;
	  exit (EXIT_FAILURE);
	}
      } else {
	cerr << "Node " << c_ptr->src_label << " does not exist. Aborting..." << endl;
	exit (EXIT_FAILURE);
      }
    }
  } catch (boost::property_tree::ptree_bad_data& err) {
    cerr << err.what () << endl;
    exit (EXIT_FAILURE);
  } catch (boost::property_tree::ptree_bad_path& err) {
    /* this is allowed to support one node deployments for debugging */
    cerr << "No connections are defined " << endl;
  }

  if (net_ptr->tm_node == NULL) {
    cerr << "No TM node is defined. Aborting..." << endl;
    exit (EXIT_FAILURE);
  }
  if (net_ptr->rv_node == NULL) {
    cerr << "No RV node is defined. Aborting..." << endl;
    exit (EXIT_FAILURE);
  }
}

void
load_node (network_ptr net_ptr, node_ptr n_ptr, const boost::property_tree::ptree &pt)
{
  try {
    /* mandatory */
    n_ptr->label = pt.get<string> ("label");
    if (n_ptr->label.length () != NODEID_LEN) {
      cerr << "Label " << n_ptr->label << " is not " << NODEID_LEN << " bytes long. Aborting..." << endl;
      exit (EXIT_FAILURE);
    }

    /* optional - with default values */
    n_ptr->is_rv = pt.get<bool> ("is_rv", false);
    n_ptr->is_tm = pt.get<bool> ("is_tm", false);

    string internal_link_id_str = pt.get<string> ("internal_link_id");
    n_ptr->internal_link_id = bitvector (internal_link_id_str);

  } catch (boost::property_tree::ptree_bad_data& err) {
    cerr << err.what () << endl;
    exit (EXIT_FAILURE);
  } catch (boost::property_tree::ptree_bad_path& err) {
    cerr << "missing mandatory node parameter - " << err.what () << endl;
    exit (EXIT_FAILURE);
  }
}

void
load_connection (connection_ptr c_ptr, const boost::property_tree::ptree &pt)
{
  try {
    /* mandatory */
    c_ptr->src_label = pt.get<string> ("src_label");
    c_ptr->dst_label = pt.get<string> ("dst_label");

    if (c_ptr->src_label.compare (c_ptr->dst_label) == 0) {
      cerr << "src_label and dst_label must not be the same. Aborting..." << endl;
      exit (EXIT_FAILURE);
    }

    string link_id_str = pt.get<string> ("link_id");
    c_ptr->link_id = bitvector (link_id_str);

  } catch (boost::property_tree::ptree_bad_data& err) {
    cerr << err.what () << endl;
    exit (EXIT_FAILURE);
  } catch (boost::property_tree::ptree_bad_path& err) {
    cerr << "missing mandatory connection parameter - " << err.what () << endl;
    exit (EXIT_FAILURE);
  }
}

void
create_graph (network_graph_ptr net_graph_ptr, network_ptr net_ptr)
{
  typedef std::pair<std::string, connection_ptr> connection_map_pair_t;
  typedef std::pair<std::string, node_ptr> node_map_pair_t;

  vertex src_v, dst_v;

  map<string, vertex>::iterator vertices_map_iter;

  /* iterate over all nodes in net_graph and add respective vertices in the graph*/
  BOOST_FOREACH(node_map_pair_t node_pair, net_ptr->nodes) {
    node_ptr src_n_ptr = node_pair.second;
    /* check if this node is already added in the network graph */
    vertices_map_iter = vertices_map.find (src_n_ptr->label);
    if (vertices_map_iter == vertices_map.end ()) {
      /* add the node in the boost graph */
      src_v = add_vertex (src_n_ptr, *net_graph_ptr);
      vertices_map.insert (pair<string, vertex> (src_n_ptr->label, src_v));
    } else {
      src_v = (*vertices_map_iter).second;
    }
    /* iterate over all connections in net_graph and add respective edges in the graph */
    BOOST_FOREACH(connection_map_pair_t connection_pair, src_n_ptr->connections) {
      connection_ptr c_ptr = connection_pair.second;
      node_ptr dst_n_ptr = net_ptr->nodes[c_ptr->dst_label];
      /* check if destination node is a vertex in the boost graph */
      vertices_map_iter = vertices_map.find (dst_n_ptr->label);
      if (vertices_map_iter == vertices_map.end ()) {
	/* add the node in the boost graph */
	dst_v = add_vertex (dst_n_ptr, *net_graph_ptr);
	vertices_map.insert (pair<string, vertex> (dst_n_ptr->label, dst_v));
      } else {
	dst_v = (*vertices_map_iter).second;
      }
      /* add the connection in the boost graph */
      add_edge (src_v, dst_v, c_ptr, *net_graph_ptr);
    }
  }
}
//
//void
//calculate_forwarding_id (network_graph_ptr net_graph_ptr, vertex src_v, vertex dst_v, vector<vertex> &predecessor_vector, bitvector &lipsin)
//{
////  vertex predeccesor;
////  node_ptr n;
////
////  /* source node is the same as destination */
////  if (dst_v == src_v) {
////    /* XOR lipsin with dst_v == src_v internal_link_id and return */
////    lipsin ^= (*net_graph_ptr)[dst_v]->internal_link_id;
////    return;
////  }
////
////  while (true) {
////    /* XOR lipsin with dst_v internal_link_id */
////    n = (*net_graph_ptr)[dst_v];
////    lipsin ^= n->internal_link_id;
////
////    /* find the predeccesor node */
////    predeccesor = predecessor_vector[dst_v];
////    pair<edge, bool> edge_pair = boost::edge (predeccesor, dst_v, *net_graph_ptr);
////    if (edge_pair.second == false) {
////      /* this should never happen - an edge must always exist */
////      cout << "Fatal: No edge between " << (*net_graph_ptr)[predeccesor]->label << " and " << (*net_graph_ptr)[dst_v]->label << ". Aborting..." << endl;
////      exit (EXIT_FAILURE);
////    }
////    /* XOR with edge's link_id */
////    lipsin ^= (*net_graph_ptr)[edge_pair.first]->link_id;
////
////    /* done */
////    if (predeccesor == src_v) {
////      break;
////    }
////
////    /* move on to the next iteration */
////    dst_v = predeccesor;
////  }
//}

void
calculate_forwarding_ids (network_graph_ptr net_graph_ptr)
{
  /* a predecessor vector used by BFS */
  vector<vertex> predecessor_vector (boost::num_vertices (*net_graph_ptr));

  /* iterate over all vertices in the boost graph */
  BOOST_FOREACH(vertex v, vertices(*net_graph_ptr)) {
    /* all weights are 1 so, as boost suggests, I am running a BFS with a predecessor map */
    boost::breadth_first_search (*net_graph_ptr, v, boost::visitor (boost::make_bfs_visitor (boost::record_predecessors (&predecessor_vector[0], boost::on_tree_edge ()))));

//    /* calculate lipsin identifier to the target node - use the predecessor map above */
//    (*net_graph_ptr)[v]->lipsin_rv = bitvector (FID_LEN * 8);
//    calculate_forwarding_id (net_graph_ptr, v, rv_v, predecessor_vector, (*net_graph_ptr)[v]->lipsin_rv);
//
//    (*net_graph_ptr)[v]->lipsin_tm = bitvector (FID_LEN * 8);
//    calculate_forwarding_id (net_graph_ptr, v, tm_v, predecessor_vector, (*net_graph_ptr)[v]->lipsin_tm);
  }
}

void
calculate_routing_table (network_graph_ptr net_graph_ptr)
{

}
